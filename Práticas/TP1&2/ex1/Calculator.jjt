options {
    LOOKAHEAD = 2;
}

PARSER_BEGIN(Calculator)


// Java code invoking the parser
public class Calculator {

    public static void main(String[] args) throws ParseException {
        System.out.println("Parser for a calculator that accepts expressions with integers, +,-,*,/,(, and ).");
        System.out.println("Write an arithmetic expression:");
        Calculator myCalc = new Calculator(System.in);

        SimpleNode root = myCalc.Expression(); // returns reference to root node

        root.dump(""); // prints the tree on the screen
        System.out.println("Expression value: " + myCalc.eval(root));
    }

    int eval(SimpleNode node) {
        if(node.jjtGetNumChildren() == 0) // leaf node with integer value
            return node.val;
        else if(node.jjtGetNumChildren() == 1) // only one child
            return this.eval((SimpleNode) node.jjtGetChild(0));

        SimpleNode lhs = (SimpleNode) node.jjtGetChild(0); //left child
        SimpleNode rhs = (SimpleNode) node.jjtGetChild(1); // right child
        switch(node.id) {
            case CalculatorTreeConstants.JJTADD:  return eval( lhs ) + eval( rhs );
            case CalculatorTreeConstants.JJTSUB: return eval( lhs ) - eval( rhs );
            case CalculatorTreeConstants.JJTMUL: return eval( lhs ) * eval( rhs );
            case CalculatorTreeConstants.JJTDIV: return eval( lhs ) / eval( rhs );
            default : // abort
                System.out.println("Illegal operator: " + node.id);

                System.exit(1);
        }
        return 0;
    }
}

PARSER_END(Calculator)
// Symbols that must be skipped during the lexical analysis
SKIP :
{
" " | "\t" | "\r"
}

// token definition (terminal symbols)
TOKEN :
{
    < INTEGER : (["0" - "9"])+ >
    | < LF : "\n" >
    | <SYMBOL : ["A"-"Z", "a"-"z"] (["0"-"9","A"-"Z","a"-"z"])*>
    | <EQUAL : "=">
    | <PVIRG : ";">
}

SimpleNode Expression(): {}
{
    (Decl())*
    Expr1() <PVIRG> <LF> {return jjtThis;} // Java code inside brackets

}
void Decl() #void: {Token t1, t2;}{
    t1=<SYMBOL>
    <EQUAL>
    t2=<INTEGER> {SymbolsTable.put(t1.image, Integer.parseInt(t2.image));}
    <PVIRG>
    <LF>
}

void Expr1() #void: {}
{
    Expr2(1)
    [
        ("+" Expr2(1) #Add(2)
        | "-" Expr2(1) #Sub(2))
    ]
}

void Expr2(int sign) #void: {} // 1: positive; -1: negative
{
    Expr3(sign)
        ("*" Expr3(1) #Mul(2)
        | "/" Expr3(1) #Div(2)
    )? // (…)?equivalent to […]
}

void Expr3(int sign) #void: {Token t;}
{
    (
        t=<INTEGER>
        {
            jjtThis.val = sign * Integer.parseInt(t.image);
        }
        | t=<SYMBOL>{ jjtThis.val = sign * SymbolsTable.get(t.image);}
    ) #Term 
    | "-" Expr3(-1)
    | "(" Expr1() ")"

}

