/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. S3_10.jj */
/*@egen*/options {
    LOOKAHEAD = 3;
}

PARSER_BEGIN(S3_10)


// Java code invoking the parser
public class S3_10/*@bgen(jjtree)*/implements S3_10TreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTS3_10State jjtree = new JJTS3_10State();

/*@egen*/
    public static void main(String[] args) throws ParseException {
        System.out.println("Write an arithmetic expression:");
        S3_10 parser = new S3_10(System.in);
        SimpleNode root = parser.Expression(); // returns reference to root node

        root.dump(""); // prints the tree on the screen

    }


}

PARSER_END(S3_10)
// Symbols that must be skipped during the lexical analysis
SKIP :
{
" " | "\t" | "\r" | "\n"
}

// token definition (terminal symbols)
TOKEN :
{
    < INT: "int" > |
    < IDENT: ["a"-"z"]["0"-"9", "a"-"z"]> |
    < VIRG: ","> |
    < PVIRG: ";"> |
    < CONST : (["0" - "9"])+ > |
    < IGUAL: "="> |
    < MULT : "*">
}

SimpleNode Expression(): {/*@bgen(jjtree) Expression */
  SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Expression */
    try {
/*@egen*/
    (Decl())*
    (AttriConst())*
    (AttriExpr())*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Decl(): {/*@bgen(jjtree) Decl */
  SimpleNode jjtn000 = new SimpleNode(JJTDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Decl */
    try {
/*@egen*/
    <INT> <IDENT> {System.out.println("helo");}(<VIRG> <IDENT>)* <PVIRG>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void AttriConst(): {/*@bgen(jjtree) AttriConst */
  SimpleNode jjtn000 = new SimpleNode(JJTATTRICONST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AttriConst */
    try {
/*@egen*/
    <IDENT> <IGUAL> <CONST> <PVIRG>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void AttriExpr(): {/*@bgen(jjtree) AttriExpr */
  SimpleNode jjtn000 = new SimpleNode(JJTATTRIEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AttriExpr */
    try {
/*@egen*/
    <IDENT> <IGUAL> Expr() <PVIRG>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Expr(): {/*@bgen(jjtree) Expr */
  SimpleNode jjtn000 = new SimpleNode(JJTEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Expr */
    try {
/*@egen*/
    <IDENT> <MULT> <IDENT>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}